
package adapterPattern;

// 适配器模式
// 定义：将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作
// 又叫做变压器模式，也叫做包装模式（Wrapper），但是包装模式可不止一个，还包括了装饰模式
/*
 * ● Target目标角色
 * 
 * 就是我们的期望接口，例子中的IUserInfo接口 就是目标角色。
 * 
 * ● Adaptee源角色
 * 
 * 已经存在的、运行良好的类或对 象，经过适配器角色的包装，它会成为一个崭新、靓丽的角色。
 *
 * ● Adapter适配器角色
 *
 * 适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建 立的，它的职责非常简单：把源角色转换为目标角色，怎么转换？通过继承或是类关联的方 式。
 */
/*
 * 【优点】
 * 
 * ● 适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定 他们就成。
 * 
 * ● 增加了类的透明性（我们访问的Target目标角色，但是具体的实现都委托给了源角色，而这些对高 层次模块是透明的，也是它不需要关心的。）
 *
 * ● 提高了类的复用度
 *
 * ● 灵活性非常好（某一天，突然不想要适配器，没问题，删除掉这个适配器就可以了）
 *
 * 【使用场景】
 *
 * 有动机修改一个已经投产中的接口时，适 配器模式可能是最适合你的模式。
 * 
 * 比如系统扩展了，需要使用一个已有或新建立的类，但这 个类又不符合系统的接口。
 * 
 * 【注意事项】
 * 
 * 适配器模式最好在详细设计阶段不要考虑它，它不是为了解决还处在开发阶段的问题， 而是解决正在服役的项目问题。
 * 
 * 项目一定要遵守依赖倒置原则和里氏替换原则，否则即使在适合使用适 配器的场合下，也会带来非常大的改造。
 * 
 * 【扩展】
 * 
 * 如果待转换的接口不止一个，总共有三个接口三个实现类。Java是不支持多继承，此路不通。
 * 
 * 解决方案：类关联，即对象适配器。声明一个 OuterUserInfo实现类，实现IUserInfo接口，通过再关联其他三个【实现类】就可以解决这个问 题了。 之前通过继承进行的适配，叫做类适配器
 */

// 适配器模式是一个补偿模式，或者说是一个“补救”模式。
